{"version":3,"file":"static/webpack/static/development/pages/index.js.8cfaafeea1ce8484db06.hot-update.js","sources":["webpack:///./pages/index.js"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\nimport { apply, Canvas, useRender, useThree, useUpdate } from 'react-three-fiber';\nimport * as THREE from 'three';\n\nimport { OrbitControls } from '../resources';\n\napply({ OrbitControls });\n\nconst affectPosition = (x, y, z, trait) => {\n    return [x, y, z].map(p => {\n        return p * Math.cos(p * trait) * Math.abs(Math.sin(p * trait)) * 2;\n    });\n};\n\nconst Orb = ({ value }) => {\n    const color = \"#FFFFFF\";\n    // const color = useMemo(() => {\n    //     const hex = Math.round(0xFFFFFF / value).toString(16);\n    //     return `#${hex.length === 5 ? '0' + hex : hex}`;\n    // }, [value]);\n\n    const geoRef = useUpdate(geometry => {\n        geometry.morphAttributes.position = [];\n        const positions = geometry.attributes.position.array;\n        const scalePositions = [];\n        const vertex = new THREE.Vector3();\n        for (let p = 0; p < positions.length; p += 3) {\n            const x = positions[p];\n            const y = positions[p + 1];\n            const z = positions[p + 2];\n            vertex.set(...affectPosition(x, y, z, value));\n            vertex.toArray(scalePositions, scalePositions.length);\n        }\n        geometry.morphAttributes.position[0] = new THREE.Float32BufferAttribute(scalePositions, 3);\n    }, [value]);\n\n    return (\n        <mesh\n            position={[0, 0, 0]}\n            morphTargetInfluences={[1]}\n        >\n            <icosahedronBufferGeometry\n                args={[50, 1]}\n                ref={geoRef}\n                attach=\"geometry\"\n                onUpdate={geometry => {\n                    geometry.attributes.position.needsUpdate = true;\n                    geometry.computeBoundingSphere();\n                }}\n            />\n            <meshPhongMaterial\n                attach=\"material\"\n                flatShading={true}\n                morphTargets={true}\n                color={color}\n            />\n        </mesh>\n    );\n};\n\nconst Content = ({ value }) => {\n    const cameraRef = useRef();\n    const controlsRef = useRef();\n    const { canvas, size, setDefaultCamera } = useThree();\n\n    useEffect(() => void setDefaultCamera(cameraRef.current), []);\n    useRender(() => controlsRef.current.update());\n\n    return (\n        <>\n            <perspectiveCamera\n                ref={cameraRef}\n                aspect={size.width / size.height}\n                radius={(size.width + size.height) / 4}\n                fov={55}\n                position={[70, 70, 200]}\n                onUpdate={self => self.updateProjectionMatrix()}\n            />\n\n            <ambientLight args={[0x404040]} />\n            <pointLight args={[0xCCCCCC, 0.8]} position={[-400, 400, 500]} />\n            <pointLight args={[0xCCCCCC, 0.8]} position={[300, 100, -500]} />\n            <pointLight args={[0xCCCCCC, 0.8]} position={[400, -400, 500]} />\n\n            {cameraRef.current && (\n                <>\n                    <orbitControls\n                        ref={controlsRef}\n                        args={[cameraRef.current, canvas]}\n                    />\n                    <Orb value={value} />\n                </>\n            )}\n        </>\n    );\n};\n\nexport default () => {\n    const [value, setValue] = useState(1.5);\n    return (\n        <>\n            <style jsx global>{`\n                html,\n                body,\n                #__next {\n                    width: 100%;\n                    height: 100%;\n                    margin: 0;\n                    padding: 0;\n                    overflow: hidden;\n                    background: #272727;\n                    position: relative;\n                }\n\n                .controls {\n                    position: absolute;\n                    width: 80vw;\n                    height: 1rem;\n                    left: 50%;\n                    bottom: 5rem;\n                    transform: translate(-50%);\n                    z-index: 1;\n                    background-color: lightgray;\n                    padding: 0.5rem;\n                }\n\n                .controls input {\n                    width: 100%;\n                    margin: 0;\n                }\n            `}</style>\n            <div className=\"controls\">\n                <input\n                    type=\"range\"\n                    min=\"1\"\n                    max=\"2\"\n                    step=\"0.001\"\n                    value={value}\n                    onChange={evt => setValue(parseFloat(evt.target.value))}\n                />\n            </div>\n            <Canvas>\n                <Content value={value} setValue={setValue} />\n            </Canvas>\n        </>\n    );\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AACA;AACA;AACA;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;AACA;AAAA;AACA;AACA;AACA;AAHA;AAAA;AAAA;AAAA;AACA;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AACA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AA+BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;;;;A","sourceRoot":""}